// src/main/java/com/cognix/DAO/ReportDAO.java
package com.cognix.DAO;

import com.cognix.config.DbConfig;
import com.cognix.model.Model;
import com.cognix.model.ReportData;

import java.math.BigDecimal;
import java.sql.*;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

public class ReportDAO {
    private final Connection conn;

    public ReportDAO() {
        try {
            this.conn = DbConfig.getDbConnection();
        } catch (SQLException e) {
            throw new RuntimeException("Unable to connect to DB", e);
        }
    }

    /** 1) Total number of models listed by this seller. */
    public int getTotalModelsListed(int sellerId) throws SQLException {
        String sql = "SELECT COUNT(*) FROM Models WHERE SellerUserID = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() ? rs.getInt(1) : 0;
            }
        }
    }

    /** 2) Total number of orders received by the seller. */
    public int getTotalOrdersReceived(int sellerId) throws SQLException {
        String sql = "SELECT COUNT(*) FROM OrdersReceived WHERE SellerUserID = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() ? rs.getInt(1) : 0;
            }
        }
    }

    /** 3) Total revenue generated by the seller. */
    public BigDecimal getTotalRevenueGenerated(int sellerId) throws SQLException {
        String sql = "SELECT COALESCE(SUM(Price),0) FROM OrdersReceived WHERE SellerUserID = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() ? rs.getBigDecimal(1) : BigDecimal.ZERO;
            }
        }
    }

    /** 4) Best‐selling model name (most orders). */
    public String getBestSellingModel(int sellerId) throws SQLException {
        String sql =
          "SELECT m.Name " +
          "FROM OrdersReceived o " +
          "JOIN Models m ON o.ModelID = m.ModelID " +
          "WHERE m.SellerUserID = ? " +
          "GROUP BY o.ModelID " +
          "ORDER BY COUNT(*) DESC " +
          "LIMIT 1";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() ? rs.getString("Name") : null;
            }
        }
    }

    /** 5) Revenue‐over‐time chart data. */
    public ReportData<BigDecimal> getRevenueOverTime(int sellerId,
                                                     LocalDate from,
                                                     LocalDate to,
                                                     String sort) throws SQLException {
        String sql =
          "SELECT DATE(o.OrderDate) AS dt, SUM(o.Price) AS total " +
          "FROM OrdersReceived o " +
          "JOIN Models m ON o.ModelID = m.ModelID " +
          "WHERE m.SellerUserID = ? " +
            "AND o.OrderDate BETWEEN ? AND ? " +
          "GROUP BY DATE(o.OrderDate) " +
          ( "least-revenue".equals(sort)
            ? "ORDER BY total ASC"
            : "most-revenue".equals(sort)
              ? "ORDER BY total DESC"
              : "ORDER BY dt ASC"
          );
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            ps.setDate(2, Date.valueOf(from));
            ps.setDate(3, Date.valueOf(to));
            try (ResultSet rs = ps.executeQuery()) {
                List<String> labels = new ArrayList<>();
                List<BigDecimal> data = new ArrayList<>();
                while (rs.next()) {
                    labels.add(rs.getDate("dt").toString());
                    data.add(rs.getBigDecimal("total"));
                }
                return new ReportData<>(labels, data);
            }
        }
    }
    
    /** 6) Units‐sold‐per‐model chart data: includes zero‐sale models */
    public ReportData<Integer> getUnitsSoldPerModel(int sellerId,
                                                    LocalDate from,
                                                    LocalDate to,
                                                    String modelNameFilter,
                                                    String sort) throws SQLException {
        // Normalize name filter
        String nameFilter = (modelNameFilter != null && !modelNameFilter.isBlank())
                          ? "%" + modelNameFilter + "%"
                          : "%";

        // Determine ORDER BY clause
        String orderClause;
        switch ((sort == null ? "" : sort).toLowerCase()) {
            case "least-sold":
                orderClause = "ORDER BY sold ASC";
                break;
            case "oldest":
                orderClause = "ORDER BY first_order ASC";
                break;
            case "latest":
                orderClause = "ORDER BY last_order DESC";
                break;
            default:  // most-sold or any other
                orderClause = "ORDER BY sold DESC";
        }

        String sql =
          "SELECT " +
          "  m.Name AS model, " +
          "  COALESCE(SUM(CASE WHEN o.OrderDate BETWEEN ? AND ? THEN 1 ELSE 0 END),0) AS sold, " +
          "  MIN(CASE WHEN o.OrderDate BETWEEN ? AND ? THEN o.OrderDate END) AS first_order, " +
          "  MAX(CASE WHEN o.OrderDate BETWEEN ? AND ? THEN o.OrderDate END) AS last_order " +
          "FROM Models m " +
          "LEFT JOIN OrdersReceived o " +
          "  ON m.ModelID = o.ModelID " +
          "  AND o.OrderDate BETWEEN ? AND ? " +
          "WHERE m.SellerUserID = ? " +
          "  AND m.Name LIKE ? " +
          "GROUP BY m.Name " +
          orderClause;

        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            int idx = 1;
            // For sold COUNT CASE
            ps.setDate(idx++, Date.valueOf(from));
            ps.setDate(idx++, Date.valueOf(to));
            // For first_order MIN(CASE...)
            ps.setDate(idx++, Date.valueOf(from));
            ps.setDate(idx++, Date.valueOf(to));
            // For last_order MAX(CASE...)
            ps.setDate(idx++, Date.valueOf(from));
            ps.setDate(idx++, Date.valueOf(to));
            // JOIN date filter
            ps.setDate(idx++, Date.valueOf(from));
            ps.setDate(idx++, Date.valueOf(to));
            // Seller ID and name filter
            ps.setInt(idx++, sellerId);
            ps.setString(idx, nameFilter);

            try (ResultSet rs = ps.executeQuery()) {
                List<String> labels = new ArrayList<>();
                List<Integer> data  = new ArrayList<>();
                while (rs.next()) {
                    labels.add(rs.getString("model"));
                    data.add(rs.getInt("sold"));
                }
                return new ReportData<>(labels, data);
            }
        }
    }



    /**
     * 7) Top‐models table: category‐filterable and sortable by sales/revenue.
     *    Entire SQL is in one String literal.
     */
    public List<Model> getTopModels(int sellerId,
                                    String categoryFilter,
                                    String sortBy) throws SQLException {
        String sql =
          "SELECT m.ModelID, m.Name, m.Catagory AS category, m.ListedDate, m.Price, " +
          "       COUNT(o.OrderID)   AS totalSales, " +
          "       COALESCE(SUM(o.Price),0) AS totalRevenue " +
          "  FROM Models m " +
          "  LEFT JOIN OrdersReceived o ON m.ModelID = o.ModelID " +
          " WHERE m.SellerUserID = ? " +
          "   AND (? IS NULL OR LOWER(m.Catagory)=LOWER(?)) " +
          " GROUP BY m.ModelID " +
          ( "revenue-asc".equals(sortBy)
            ? " ORDER BY totalRevenue ASC"
            : "revenue-desc".equals(sortBy)
              ? " ORDER BY totalRevenue DESC"
              : "sales-asc".equals(sortBy)
                ? " ORDER BY totalSales ASC"
                : " ORDER BY totalSales DESC"
          );

        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            if (categoryFilter == null || categoryFilter.isBlank()) {
                ps.setNull(2, Types.VARCHAR);
                ps.setNull(3, Types.VARCHAR);
            } else {
                ps.setString(2, categoryFilter);
                ps.setString(3, categoryFilter);
            }

            List<Model> list = new ArrayList<>();
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    Model m = new Model();
                    m.setModelId(      rs.getInt   ("ModelID"));
                    m.setName(         rs.getString("Name"));
                    m.setCategory(     rs.getString("category"));
                    m.setListedDate(   rs.getDate  ("ListedDate"));
                    m.setPrice(        rs.getDouble("Price"));
                    m.setSales(   rs.getInt   ("totalSales"));
                    m.setRevenue( rs.getBigDecimal("totalRevenue"));
                    list.add(m);
                }
            }
            return list;
        }
    }

    /** 8) When was their last order? */
    public Timestamp getLatestOrderDate(int sellerId) throws SQLException {
        String sql =
          "SELECT MAX(o.OrderDate) AS latest " +
          "FROM OrdersReceived o " +
          "JOIN Models m ON o.ModelID = m.ModelID " +
          "WHERE m.SellerUserID = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next() ? rs.getTimestamp("latest") : null;
            }
        }
    }
    
    /** Return a list of distinct category names for this seller’s models. */
    public List<String> getDistinctCategoriesForSeller(int sellerId) throws SQLException {
        String sql = "SELECT DISTINCT Catagory FROM Models WHERE SellerUserID = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, sellerId);
            try (ResultSet rs = ps.executeQuery()) {
                List<String> cats = new ArrayList<>();
                while (rs.next()) {
                    cats.add(rs.getString("Catagory"));
                }
                return cats;
            }
        }
    }

}
